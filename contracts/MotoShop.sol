// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/*
    Задача: Написать контракт который в процессе покупки
    будет проверять зашли ли нам деньги на счет если да
    то в таком случае если да то мы продаем товар и мы
    хотим убедиться что мы можем вывести деньги с нашего
    кошелька.
*/

contract MopedShop {
    uint public price = 2 ether; // unsigned integer
    uint public small_price = 2; // wei -- самая маленькая часть криптовалюты (копейка)

    address public ownerAddress; // адресс продавца address в solidity это тип данных
    address public shopAddress;
    /*
        Адресс есть у учетных записей в блокчейне (зачастую кошелек)
        А так же адресс есть у самих контрактов.

        Стоит задача сохранить адресс в момент когда
        смартконтракта разворачиваеться в сети блокчейн
        нужно что бы только в момент разворачивания смартконтракта
        устанавливался адресс только того кто его разворачивает
        это сделано для того что бы только владелец
        нашего смартконтракта мог списывать средства

        constructor -- это специальная функция которая вызываеться
        в момент разворачивания контракта;
    */

    constructor() {
        ownerAddress = msg.sender;
        /*
            msg -- это глобальный обьект который доступный в смарт контрактах сам контракт.
            msg.sender -- тот кто запускает траназакцию так как развертывание транзакции
            это тоже транзакция будет выбран наш пользователь.
        */
        shopAddress = address(this); // указывает на этот контракт и конвертирует в address.
    }

    // модификатор view говорит о том что функция ничего менять не будет будет только читать
    // public, returns -- понятно это как в C#
    function getBalance() public view returns(uint) {
        // каждый контракт имеет в себе n-количество средств
        // нам известен баланс все участников сети blockchain
        // в solidity мы можем посмотреть баланс вызвав у адреса balance
        return shopAddress.balance;
    }

    // специальная функция по приему платежей
    // external означает что функция будет вызваться только из в не контракта
    // в самом контракте это функция вызваться не может
    receive() external payable {

    }
}
